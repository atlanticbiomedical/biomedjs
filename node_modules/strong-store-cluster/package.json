{
  "name": "strong-store-cluster",
  "version": "0.1.3",
  "description": "In-memory key/value store for the node's native cluster.",
  "readmeFilename": "README.md",
  "license": "MIT",
  "keywords": [
    "cluster",
    "store"
  ],
  "author": {
    "name": "Bert Belder",
    "email": "bert@strongloop.com"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/strongloop/strong-store-cluster.git"
  },
  "bugs": {
    "url": "https://github.com/strongloop/strong-store-cluster/issues"
  },
  "main": "index.js",
  "scripts": {
    "blanket": {
      "pattern": "//^((?!(node_modules|test)).)*$/"
    },
    "coverage": "mocha -r blanket -R html-cov > coverage_strong-store-cluster.html",
    "test": "mocha --reporter spec --timeout 5000 --slow 1000 --ui tdd"
  },
  "devDependencies": {
    "blanket": "latest",
    "mocha": "~1.9.0"
  },
  "engines": {
    "node": ">=0.10"
  },
  "readme": "# Strong Store Cluster\n\nStrong Store for Cluster provides a key/value collection that can be accesses by\nall processes in a node cluster.\n\n## Example\n\n```javascript\n// get the collection and give it a name\nvar collection = require('strong-store-cluster').collection('test');\n\n// don't let keys expire, ever - the number represents seconds\ncollection.configure({ expireKeys: 0 });\n\ncollection.set('ThisIsMyKey', { a: 0, b: 'Hiya', c: { d: 99}}, function(err) {\n  if (err) {\n    console.error('There was an error');\n    return;\n  }\n\n  collection.get('ThisIsMyKey', function(err, obj) {\n    if (err) {\n      console.error('There was an error in collection.get.');\n      return;\n    }\n\n    console.log('The object: ',obj);\n  });\n});\n```\n\n## API documentation\n\n### store.collection(name)\n\nReturns a Collection object which lets you share data between node processes.\n\n### Class: Collection\n\nA `Collection` instance provides access to a shared key-value store\nshared by multiple node instances.\n\nHow collections are named and stored is determined by the storage backend. The\n`strong-store-cluster` implementation stores collections in the master process\n(if you're using cluster), and accepts any arbitrary string as a collection\nname.\n\nA `Collection` object is also an `EventEmitter`.\n\n\n#### collection.configure([options])\n\n* `options` (`Object`) contains configurations options to be changed\n  * `expireKeys` (`Number`) seconds after which keys in this\n    collection are to be expired.\n\nSet configuration options for the collection.\n\nCurrently only one configurable option is supported: `expireKeys`. When set\nto a nonzero value, keys will automatically expire after they've not been\nread or updated for some time. The timeout is specified in seconds. There's no\nguarantee that the key will be discared after exactly that number of seconds\nhas passed. However keys will never be automatically deleted _sooner_ than what\nthe `expireKeys` setting allows.\n\nIt is perfectly legal to call the `configure` method from multiple node\nprocesses (e.g. both in a worker and in the master process). However you\nshould be careful to set the _same_ option values every time, otherwise the\neffect is undefined.\n\n\n#### collection.get(key, callback)\n\n* `key` (`String`) key to retrieve\n* `callback` (`Function`) called when the value has been retrieved\n\nRead the value associated with a particular key. The callback is called with\ntwo arguments, `(err, value)`. When the key wasn't found in the collection, it\nis automatically created and it's `value` is set to `undefined`.\n\n\n#### collection.set(key, [value], [callback])\n\n* `key` (`String`) key to set or update\n* `value` (`object`) value to associate with the key\n* `callback` (`Function`) called when the value has been retrieved\n\nSet the value associated with `key`. The `value` must be either undefined or\na value that can be serialized with JSON.stringify.\n\nWhen the `value` parameter is omitted or set to `undefined`, the key is\ndeleted, so effectively it's the same as calling `collection.del(key)`.\n\nThe `callback` function receives only one argument, `err`. When the\ncallback is omitted, the master process does not send a confirmation\nafter updating the key, and any errors are silently ignored.\n\n\n#### collection.del(key, [callback])\n\n* `key` (`String`) key to delete\n* `callback` (`Function`) called when the value has been retrieved\n\nDelete a key from the collection.\n\nThis operation is the equivalent of setting the key to `undefined`.\n\nThe `callback` function receives only one argument, `err`. When the\ncallback is omitted, the master process does not send a confirmation\nafter deleting the key, and any errors are silently ignored.\n\n\n#### collection.acquire(key, callback)\n\n* `key` (`String`) key to delete\n* `callback` (`Function`) called when the key has been locked\n\nLock a key for exclusive read and write access.\n\nThe `acquire` methods waits until it can grab an exclusive lock on the\nspecified key. When the lock is acquired, no other process can read, write or\ndelete this particular key. When the lock is no longer needed, it should be\nrelinquished with `keylock.release()`.\n\nThree parameters are passed to the `callback` function:\n`(err, keylock, value)`. The `keylock` argument receives a `KeyLock` class\ninstance, which lets you read and manipulate the key's value as well as\neventually release the lock. The `value` argument is set to the initial value\nassociated with the key.\n\n\n#### Event: 'error'\n\n* `err` (`Error`)\n\nThe error event is emitted whenever an unrecoverable error is encountered.\n\n### Class: KeyLock\n\nA `KeyLock` instance represents a key that has been locked. The `KeyLock`\nclass implements methods that lets you manipulate the key and release\nthe lock.\n\n\n#### keylock.get()\n\n* Returns: (`Object`) value that's currently associated with the key\n\nThis function returns the value that's currently associated with the locked\nkey.\n\nInitially this is the same as the `value` argument that was passed to the\n`collection.acquire()` callback, but it does immediately reflect changes that\nare made with `keylock.set()` and `keylock.del()`.\n\n\n#### keylock.set([value])\n\nUpdates the value associated with a locked key.\n\nThe change isn't pushed back to the master process immediately; the change\nis committed when the lock is released again. The change however is reflected\nimmediately in the return value from `keylock.get()`.\n\nAfter the lock has been released, the key can no longer be updated through the\n`KeyLock` instance. Any attempt to do so will make it throw.\n\nSetting the value to `undefined` marks the key for deletion, e.g. it's\nequivalent to `keylock.del()`.\n\n\n#### keylock.del()\n\nMark a locked key for deletion. See `keylock.set()`.\n\n\n#### keylock.release([callback])\n\nRelease the lock that protects a key. If the key was updated with\n`keylock.set()` or `keylock.del()`, these changes are committed.\n\nWhen a lock has been released, it is no longer possible to manipulate the\nkey using `KeyLock` methods. Releasing the lock twice isn't allowed either.\nThe `get()` method will still work but it won't reflect any value changes\nthat were made after releasing.\n\nThe `callback` function receives only one argument, `err`. When the\ncallback is omitted, the master process does not send a confirmation\nafter releasing the key, and any errors are silently ignored.\n",
  "_id": "strong-store-cluster@0.1.3",
  "dist": {
    "shasum": "aaab17a025b6b8809c0c1f7a796e49254cd3386c"
  },
  "_from": "strong-store-cluster@~0.1.0",
  "_resolved": "https://registry.npmjs.org/strong-store-cluster/-/strong-store-cluster-0.1.3.tgz"
}
